/**********************************

我们知道一个骰子有 6 个面，分别刻了 1 到 6 个点。
下面给你 6 个骰子的初始状态，即它们朝上一面的点数，让你一把抓起摇出另一套结果。
假设你摇骰子的手段特别精妙，每次摇出的结果都满足以下两个条件：

1、每个骰子摇出的点数都跟它之前任何一次出现的点数不同；
2、在满足条件 1 的前提下，每次都能让每个骰子得到可能得到的最大点数。
那么你应该可以预知自己第 n 次（1≤n≤5）摇出的结果。

输入格式：
输入第一行给出 6 个骰子的初始点数，即 [1,6] 之间的整数，数字间以空格分隔；
第二行给出摇的次数 n（1≤n≤5）。

输出格式：
在一行中顺序列出第 n 次摇出的每个骰子的点数。数字间必须以 1 个空格分隔，行首位不得有多余空格。

输入样例：
3 6 5 4 1 4
3

输出样例：
4 3 3 3 4 3

样例解释：
这 3 次摇出的结果依次为：

6 5 6 6 6 6
5 4 4 5 5 5
4 3 3 3 4 3

***********************************/

#include <stdio.h>

int main() {
    int init_point[6];
    int n;
    
    for (int i = 0; i < 6; i++) {
        scanf("%d", &init_point[i]);
    }
    
    scanf("%d", &n);

    int used[6][6] = {0};  //每个骰子已摇出的点数

    for (int i = 0; i < n; i++) {

        for (int j = 0; j < 6; j++) {
            int point = init_point[j] - 1;  //转换下标(映射到0~5)
            used[j][point] = 1;  //标记为已使用
            //j是第几个骰子，point是当前骰子的点数
        
            for (int k = 5; k >= 0; k--) {
                // 检查当前点数是否已经出现
                if (!used[j][k]) {
                    init_point[j] = k + 1;  //点数更新为k(最大)
                    used[j][k] = 1;   //标记为已使用
                    break;
                }
            }
        }
    }

    int first = 1;
    for (int i = 0; i < 6; i++) {
        if (first) {
            printf("%d", init_point[i]);
            first = 0;
        } else {
            printf(" %d", init_point[i]);
        }
    }

    printf("\n");

return 0;
}
