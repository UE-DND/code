/**********************************

给定n行m列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：

四周最外侧的像素点灰度值不变；

中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。

输入格式:
第一行包含两个整数n和m，表示图像包含像素点的行数和列数。
1 <= n <= 100，1 <= m <= 100。

接下来n行，每行m个整数，表示图像的每个像素点灰度。
相邻两个整数之间用单个空格隔开，每个元素均在0~255之间。

输出格式:
n行，每行m个整数，为模糊处理后的图像。
相邻两个整数之间用单个空格隔开。

输入样例:
在这里给出一组输入。例如：

4 5
100 0 100 0 50
50 100 200 0 0
50 50 100 100 200
100 100 50 50 100

输出样例:
在这里给出相应的输出。例如：

100 0 100 0 50
50 80 100 60 0
50 80 100 90 200
100 100 50 50 100

***********************************/

#include <stdio.h>

int main(void)
{
    int n, m;
    scanf("%d %d", &n, &m);
    int a[n][m];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            scanf("%d", &a[i][j]);
        }
    }

    // 创建一个数组来存储处理后的图像
    int b[n][m];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
                // 边界像素不变
                b[i][j] = a[i][j];
            } else {
                // 模糊处理
                b[i][j] = (a[i-1][j] + a[i+1][j] + a[i][j-1] + a[i][j+1] + a[i][j] + 2) / 5;
            }
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (j == m - 1) {
                printf("%d", b[i][j]);
            } else {
                printf("%d ", b[i][j]);
            }
        }
        printf("\n");
    }

	return 0;
}

