/**********************************

操场上有N x N个“巨人”按 N行N列 的矩阵形式列队，请编程找出该方阵中所有“最矮的巨人”。
所谓“最矮的巨人”是指，该巨人在其所在行中，身高最高（没人比其更高）；且在其所在列中，身高最矮（没人比其更矮）。

输入格式:
输入的第1行给出一个正整数n ( 1 ≤ n ≤ 6 )，表示方阵的行列数。随后n行，每行给出n个整数，代表巨人的身高，其间以空格作分隔。

输出格式:
如果找到至少一个“最矮巨人”，输出如下：
(第1个最矮巨人所在行下标，第1个最矮巨人所在列下标) 
(第2个最矮巨人所在行下标，第2个最矮巨人所在列下标) 
...
(第n个最矮巨人所在行下标，第n个最矮巨人所在列下标) 

如果没有找到“最矮巨人”，输出如下：
NONE

注意：即便输出结果只有一行，也要输出换行符。行列下标均从0开始计数。

输入样例:
4
1 7 4 6
4 6 3 6
1 6 1 6
0 7 8 7

输出样例:
(1,1)
(1,3)
(2,1)
(2,3)

***********************************/

#include <stdio.h>

int main(void) {
    int n;
    scanf("%d", &n);
    int a[n][n];

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &a[i][j]);
        }
    }

    int found = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            int max_in_row = 1;
            for (int k = 0; k < n; k++) {
                if (a[i][k] > a[i][j]) {
                    max_in_row = 0;
                    break;
                }
            }

            int min_in_column = 1;
            for (int k = 0; k < n; k++) {
                if (a[k][j] < a[i][j]) {
                    min_in_column = 0;
                    break;
                }
            }

            if (max_in_row && min_in_column) {
                printf("(%d,%d)\n", i, j);
                found = 1;
            }
        }
    }

    if (!found) {
        printf("NONE\n");
    }

    return 0;
}
